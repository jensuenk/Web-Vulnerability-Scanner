import { Injectable } from '@angular/core';
import { HttpClient, HttpHeaders } from '@angular/common/http';
import { Observable } from 'rxjs';
import { Message } from 'primeng/api';

@Injectable({
  providedIn: 'root'
})
export class WappalyzerService {
  
  key: string = 'aQQU1n9fu64JZaqIDtQHP8LylpG07VTa2UmiShcV';
  technologies: Technology[];
  technologyScans: TechnologyScan[] = [];

  exploitList: ExploitList[] = [];
  

  constructor(private http: HttpClient) {
  }

  getLookupResponse(url: string): Observable<any> {
    const headers = new HttpHeaders()
      .set('x-api-key', this.key)
      .set('Content-Type', 'application/json');

    return this.http.get<any>("https://api.wappalyzer.com/lookup/v2/?urls=" + url, { headers: headers });
  }
  getCrawlResponse(url: string): Observable<any> {
    const headers = new HttpHeaders()
      .set('x-api-key', this.key)
      .set('Content-Type', 'application/json');

    return this.http.get<any>("https://api.wappalyzer.com/crawl/v2/?urls=" + url + "&recursive=false", { headers: headers });
  }

  getVurnabilities() {
    this.technologyScans = [];
    this.technologies.forEach(vulnerability => {

      let scan: TechnologyScan = {
        name: vulnerability.name,
        versions: vulnerability.versions,
        categories: vulnerability.categories
      };
      if (vulnerability.versions == null || vulnerability.versions.length <= 0) {
        scan.versions = null;
        scan.message1 = [
          { severity: 'info', summary: 'Info', detail: "Could not detect the version of " + vulnerability.name + "." },
        ];
      }
      else {
        if (this.isVurnable(vulnerability)) {
          scan.message2 = [
            { severity: 'warn', summary: 'Warning', detail: "Found an exploit or vulnerability with the current version (" + vulnerability.versions + ") of " + vulnerability.name + ". Its recommended to update to a newer version or downgrade to a more stable version.", closable: false  },
          ];
        }
        else {
          scan.message2 = [
            { severity: 'success', summary: 'Success', detail: "Did not found any vulnerabilities with version " + vulnerability.versions + " of " + vulnerability.name + ".", closable: false  },
          ];
        }
      }

      this.technologyScans.push(scan);
    });
    console.log(this.technologyScans)
  }

  isVurnable(technology: Technology) {
    this.exploitList.forEach(exploit => {
      if (technology.name == exploit.name) {
        if (technology.versions == exploit.versions) {
          return true;
        }
      }
    })
    return false;
  }
}

export interface Category {
  id: number;
  slug: string;
  name: string;
}

export interface Technology {
  slug: string;
  name: string;
  confidence: number;
  versions?: string[];
  icon: string;
  website: string;
  cpe: string;
  categories: Category[];
}

export interface RootObject {
  urls: any;
  technologies: Technology[];
}

export interface RootObject {
  urls: any;
  technologies: Technology[];
}

export interface TechnologyScan {
  name: string;
  versions?: string[];
  categories: Category[];
  message1?: Message[];
  message2?: Message[];
  foundIssue?: boolean;
}

export interface ExploitList {
  name: string;
  versions: string[];
}